Index: pkg.c
===================================================================
RCS file: /cvsroot/installer/poldek/pkg.c,v
retrieving revision 1.51.4.5
diff -u -r1.51.4.5 pkg.c
--- pkg.c	5 May 2004 16:56:43 -0000	1.51.4.5
+++ pkg.c	11 Aug 2004 13:20:15 -0000
@@ -949,20 +949,31 @@
     return rc;
 }
 
+static int do_pkg_match_req(const struct pkg *pkg, const struct capreq *req,
+                            int strict, int pkgnvr)
+{
+    if (pkgnvr && pkg_evr_match_req(pkg, req, strict))
+        return 1;
+    return pkg_caps_match_req(pkg, req, strict);
+}
+
+
 int pkg_match_req(const struct pkg *pkg, const struct capreq *req, int strict)
 {
+    int rc, v = strcmp(pkg->name, capreq_name(req)) == 0;
+    
+    rc = do_pkg_match_req(pkg, req, 1, v);
 #if 0    
-    if (strcmp(pkg->name, "nspr") == 0 && strcmp(pkg->name, capreq_name(req)) == 0) {
-        printf("\nMATCH %d %s %s => %d\n", strict,
-               pkg_snprintf_epoch_s(pkg), capreq_snprintf_s(req),
-               pkg_evr_match_req(pkg, req, strict));
+    if (strcmp(capreq_name(req), "XFree86-OpenGL-core") == 0) {
+        printf("\n");
+        DBGF_F("%s, %s => %d; strict %d\n", pkg_snprintf_epoch_s(pkg),
+               capreq_snprintf_s(req), rc, strict);
     }
 #endif    
-    
-    if (strcmp(pkg->name, capreq_name(req)) == 0 && pkg_evr_match_req(pkg, req, strict))
-        return 1;
-    
-    return pkg_caps_match_req(pkg, req, strict);
+    if (!rc && !strict)
+        rc = do_pkg_match_req(pkg, req, 0, v);
+
+    return rc;
 }
 
 
Index: pkgset-install.c
===================================================================
RCS file: /cvsroot/installer/poldek/pkgset-install.c,v
retrieving revision 1.82.4.13
diff -u -r1.82.4.13 pkgset-install.c
--- pkgset-install.c	6 Jul 2004 18:18:00 -0000	1.82.4.13
+++ pkgset-install.c	11 Aug 2004 13:20:15 -0000
@@ -706,7 +706,7 @@
 {
     struct db_dep *db_dep;
     struct capreq *req;
-
+    
     DBGF("VUN %s: %s\n", pkg_snprintf_s(pkg), capreq_snprintf_s(cap));
     if ((db_dep = db_deps_contains(upg->db_deps, cap, 0)) == NULL) {
         DBGF("  [1] -> NO in db_deps\n");
@@ -728,7 +728,7 @@
         return 1;
     }
 
-    if (db_dep->spkg && installset_provides(db_dep->spkg, req, ps, upg)) {
+    if (db_dep->spkg && installset_provides(NULL, req, ps, upg)) {
         if (verbose > 1)
             logn(LOGWARN, "cap %s satisfied by install set, shouldn't happen",
                  capreq_snprintf_s(req));
@@ -837,6 +837,7 @@
 {
     int n, i;
     rpmdb dbh = upg->inst->db->dbh;
+    tn_array *orphans;
     
     if (upg->inst->flags & INSTS_INSTALL)
         return;
@@ -854,88 +855,84 @@
     n = 0;
     for (i=0; i < n_array_size(upg->uninst_set->dbpkgs); i++) {
         struct dbpkg *dbpkg = n_array_nth(upg->uninst_set->dbpkgs, i);
-        if ((dbpkg->flags & DBPKG_TOUCHED) == 0) {
+        if ((dbpkg->flags & DBPKG_TOUCHED))
+            continue;
+        
+        dbpkg->flags |= DBPKG_TOUCHED;    
+        msgn_i(1, indent, _("%s obsoleted by %s"), dbpkg_snprintf_s(dbpkg),
+               pkg_snprintf_s(pkg));
+        pkg_rm_mark(dbpkg->pkg);
+        db_deps_remove_pkg(upg->db_deps, dbpkg->pkg);
+        db_deps_remove_pkg_caps(upg->db_deps, pkg,
+                                (ps->flags & PSDBDIRS_LOADED) == 0);
             
-            msgn_i(1, indent, _("%s obsoleted by %s"), dbpkg_snprintf_s(dbpkg),
-                   pkg_snprintf_s(pkg));
-            pkg_rm_mark(dbpkg->pkg);
-            db_deps_remove_pkg(upg->db_deps, dbpkg->pkg);
-            db_deps_remove_pkg_caps(upg->db_deps, pkg,
-                                    (ps->flags & PSDBDIRS_LOADED) == 0);
-            
-            dbpkg->flags |= DBPKG_TOUCHED;
-            
-            if (dbpkg->pkg->caps) {
-                int j;
-                for (j=0; j < n_array_size(dbpkg->pkg->caps); j++) {
-                    struct capreq *cap = n_array_nth(dbpkg->pkg->caps, j);
-                    verify_unistalled_cap(indent, cap, dbpkg->pkg, ps, upg);
-                }
+        
+        if (dbpkg->pkg->caps) {
+            int j;
+            for (j=0; j < n_array_size(dbpkg->pkg->caps); j++) {
+                struct capreq *cap = n_array_nth(dbpkg->pkg->caps, j);
+                verify_unistalled_cap(indent, cap, dbpkg->pkg, ps, upg);
             }
+        }
 
-            if (pkg->fl && dbpkg->pkg->fl) {
-                struct capreq *cap;
-                int j, k;
-
+        if (pkg->fl && dbpkg->pkg->fl) {
+            struct capreq *cap;
+            int j, k;
+                
                 
-                cap = alloca(sizeof(cap) + PATH_MAX);
-                memset(cap, 0, sizeof(*cap));
-                cap->_buf[0] = '\0';
-                
-                for (j=0; j < n_array_size(dbpkg->pkg->fl); j++) {
-                    struct pkgfl_ent *flent = n_array_nth(dbpkg->pkg->fl, j);
-                    char *path, *endp;
-                    int path_left_size;
+            cap = alloca(sizeof(cap) + PATH_MAX);
+            memset(cap, 0, sizeof(*cap));
+            cap->_buf[0] = '\0';
+                
+            for (j=0; j < n_array_size(dbpkg->pkg->fl); j++) {
+                struct pkgfl_ent *flent = n_array_nth(dbpkg->pkg->fl, j);
+                char *path, *endp;
+                int path_left_size;
                     
-                    endp = path = &cap->_buf[1];
+                endp = path = &cap->_buf[1];
 
-                    // not needed cause depdirs module is used 
-                    //if (n_array_bsearch(ps->depdirs, flent->dirname) == NULL)
-                    //    continue;
+                // not needed cause depdirs module is used 
+                //if (n_array_bsearch(ps->depdirs, flent->dirname) == NULL)
+                //    continue;
                     
-                    if (*flent->dirname != '/')
-                        *endp++ = '/';
+                if (*flent->dirname != '/')
+                    *endp++ = '/';
                             
-                    endp = n_strncpy(endp, flent->dirname, PATH_MAX);
-                    if (*(endp - 1) != '/')
-                            *endp++ = '/';
+                endp = n_strncpy(endp, flent->dirname, PATH_MAX);
+                if (*(endp - 1) != '/')
+                    *endp++ = '/';
                     
-                    path_left_size = PATH_MAX - (endp - path);
+                path_left_size = PATH_MAX - (endp - path);
                     
-                    for (k=0; k < flent->items; k++) {
-                        struct flfile *file = flent->files[k];
+                for (k=0; k < flent->items; k++) {
+                    struct flfile *file = flent->files[k];
                         
-                        n_strncpy(endp, file->basename, path_left_size);
-                        verify_unistalled_cap(indent, cap, dbpkg->pkg, ps, upg);
-                    }
+                    n_strncpy(endp, file->basename, path_left_size);
+                    verify_unistalled_cap(indent, cap, dbpkg->pkg, ps, upg);
                 }
             }
-            
-            n += process_pkg_orphans(dbpkg->pkg, ps, upg);
         }
+        
+        n += process_pkg_orphans(dbpkg->pkg, ps, upg);
     }
+    
+    if (n == 0)
+        return;
 
-    if (n) 
-        for (i=0; i<n_array_size(upg->orphan_dbpkgs); i++) {
-            struct dbpkg *dbpkg = n_array_nth(upg->orphan_dbpkgs, i);
-            int process_as;
-            
-            if (dbpkg->flags & DBPKG_DEPS_PROCESSED)
-                continue;
+    orphans = pkgs_array_new(n_array_size(upg->orphan_dbpkgs));
+    for (i=0; i<n_array_size(upg->orphan_dbpkgs); i++) {
+        struct dbpkg *dbpkg = n_array_nth(upg->orphan_dbpkgs, i);
+        if ((dbpkg->flags & DBPKG_DEPS_PROCESSED) == 0) {
             dbpkg->flags |= DBPKG_DEPS_PROCESSED;
-#if 0
-            if ((pkg = is_pkg_obsoletedby_installset(ps, dbpkg->pkg))) {
-                process_as = PROCESS_AS_NEW;
-                
-            } else
-#endif                
-             {
-                pkg = dbpkg->pkg;
-                process_as = PROCESS_AS_ORPHAN;
-             }
-            
-            process_pkg_deps(indent, pkg, ps, upg, process_as);
+            n_array_push(orphans, pkg_link(dbpkg->pkg));
         }
+    }
+
+    for (i=0; i<n_array_size(orphans); i++) {
+        struct pkg *dbpkg = n_array_nth(orphans, i);
+        process_pkg_deps(indent, dbpkg, ps, upg, PROCESS_AS_ORPHAN);
+    }
+    n_array_free(orphans);
 }
 
 static
