--- pkgscore.c	17 Oct 2002 15:54:53 -0000	1.2
+++ pkgscore.c	14 Nov 2002 13:35:19 -0000
@@ -30,7 +30,7 @@
 #include "i18n.h"
 #include "log.h"
 #include "pkg.h"
-
+#include "pkgset.h"
 
 static
 tn_array *read_patterns(const char *fpath, tn_array *patterns, unsigned type)
@@ -108,9 +108,39 @@
 }
 
 
+
+void pkgscore_match_init(struct pkgscore_s *psc, struct pkg *pkg) 
+{
+    int n = 0;
+    
+    if (pkg->pkgdir)
+        n += n_snprintf(psc->pkgbuf, sizeof(psc->pkgbuf), "%s:", pkg->pkgdir->name);
+
+    psc->pkgname_off = n;
+    
+    pkg_snprintf(&psc->pkgbuf[n], sizeof(psc->pkgbuf) - n, pkg);
+    psc->pkg = pkg;
+}
+
+    
+
+int pkgscore_match(struct pkgscore_s *psc, const char *mask)
+{
+    if (fnmatch(mask, psc->pkg->name, 0) == 0)
+        return 1;
+
+    if (psc->pkgname_off && fnmatch(mask, &psc->pkgbuf[psc->pkgname_off], 0) == 0)
+        return 1;
+    
+    return fnmatch(mask, psc->pkgbuf, 0) == 0;
+}
+
+    
+
 void packages_score(tn_array *pkgs, tn_array *patterns, unsigned scoreflag) 
 {
     int i, j;
+    
 
     n_assert(patterns);
     if (n_array_size(patterns) == 0) 
@@ -120,23 +150,19 @@
         return;
 
     for (i=0; i < n_array_size(pkgs); i++) {
-        struct pkg *pkg = n_array_nth(pkgs, i);
-        char  pkgbuf[1024];
-        int   n = 0;
+        struct pkgscore_s  psc;
+        struct pkg         *pkg;
 
-        if (pkg->pkgdir)
-                n += n_snprintf(pkgbuf, sizeof(pkgbuf), "%s:", pkg->pkgdir->name);
-        
-        pkg_snprintf(&pkgbuf[n], sizeof(pkgbuf) - n, pkg);
+        pkg = n_array_nth(pkgs, i);
+        pkgscore_match_init(&psc, pkg);
         
-        for (j=0; j<n_array_size(patterns); j++) {
+        for (j=0; j < n_array_size(patterns); j++) {
             const char *mask = n_array_nth(patterns, j);
-            
-            if (fnmatch(mask, &pkgbuf[n], 0) == 0 || (n && fnmatch(mask, pkgbuf, 0) == 0)) {
 
+            if (pkgscore_match(&psc, mask)) {
                 switch (scoreflag) {
                     case PKG_HELD:
-                        msgn(3, "held %s", pkg_snprintf_s(pkg));
+                        msgn(1, "held %s", pkg_snprintf_s(pkg));
                         DBGMSG_F("HELD %s\n", pkg_snprintf_s(pkg));
                         pkg_score(pkg, PKG_HELD);
                         break;
--- pkgset-install.c	7 Nov 2002 16:43:26 -0000	1.79
+++ pkgset-install.c	14 Nov 2002 13:35:19 -0000
@@ -1778,15 +1778,20 @@
         return 1;
 
     for (i=0; i < n_array_size(upg->uninst_set->dbpkgs); i++) {
-        struct dbpkg *dbpkg = n_array_nth(upg->uninst_set->dbpkgs, i);
+        struct dbpkg *dbpkg; 
+        struct pkgscore_s psc;
 
+        dbpkg = n_array_nth(upg->uninst_set->dbpkgs, i);
+        pkgscore_match_init(&psc, dbpkg->pkg);
+        
         for (j=0; j < n_array_size(upg->inst->hold_patterns); j++) {
             const char *mask = n_array_nth(upg->inst->hold_patterns, j);
-
-            if (fnmatch(mask, dbpkg->pkg->name, 0) == 0) {
+            
+            if (pkgscore_match(&psc, mask)) {
                 logn(LOGERR, _("%s: refusing to uninstall held package"),
-                    pkg_snprintf_s(dbpkg->pkg));
+                     pkg_snprintf_s(dbpkg->pkg));
                 rc = 0;
+                break;
             }
         }
     }
@@ -2228,6 +2233,9 @@
     if (inst->flags & INSTS_INSTALL)
         n_assert((inst->flags & INSTS_UPGRADE) == 0);
 
+
+    packages_mark(ps->pkgs, 0, PKG_INTERNALMARK | PKG_INDIRMARK);
+
     unmark_name_dups(ps->pkgs);
     
     mem_info(1, "ENTER pkgset_install:");
@@ -2241,6 +2249,8 @@
 
     if (inst->flags & INSTS_JUSTPRINTS)
         inst->flags &= ~INSTS_PARTICLE;
+
+    
     
     for (i = 0; i < n_array_size(ps->ordered_pkgs); i++) {
         struct pkg    *pkg = n_array_nth(ps->ordered_pkgs, i);
@@ -2270,8 +2280,15 @@
         inst->flags &= ~INSTS_PARTICLE;
     
     n = 1;
-    pkgset_mark(ps, PS_MARK_OFF_ALL);
-    
+    packages_mark(ps->pkgs, 0, PKG_INDIRMARK | PKG_DIRMARK);
+    //pkgset_mark(ps, PS_MARK_OFF_ALL);
+#if 0                           /* debug */
+    for (i = 0; i < n_array_size(ps->ordered_pkgs); i++) {
+        struct pkg *pkg = n_array_nth(ps->ordered_pkgs, i);
+        if (pkg_is_marked_i(pkg)) 
+            printf("MARKED %s\n", pkg_snprintf_s(pkg));
+    }
+#endif    
     for (i = 0; i < n_array_size(ps->ordered_pkgs); i++) {
         struct pkg *pkg = n_array_nth(ps->ordered_pkgs, i);
 
@@ -2302,7 +2319,8 @@
             if (!do_install(ps, &upg, iinf))
                 nerr++;
             
-            pkgset_mark(ps, PS_MARK_OFF_ALL);
+            packages_mark(ps->pkgs, 0, PKG_INDIRMARK | PKG_DIRMARK);
+            //pkgset_mark(ps, PS_MARK_OFF_ALL);
             reset_upgrade_s(&upg);
         }
     }
@@ -2312,6 +2330,7 @@
         nerr = !do_install(ps, &upg, iinf);
 
  l_end:
+    
     destroy_upgrade_s(&upg);
     mem_info(1, "RETURN pkgset_install:");
     if (is_particle)
--- pkgset.c	24 Oct 2002 16:23:10 -0000	1.54
+++ pkgset.c	14 Nov 2002 13:35:19 -0000
@@ -725,7 +725,7 @@
     return nerr == 0;
 }
 
-
+#if 0
 static void mapfn_mark(struct pkg *pkg, unsigned *flags) 
 {
     n_assert(flags);
@@ -745,13 +745,42 @@
     }
 }
 
-
 void pkgset_mark(struct pkgset *ps, unsigned flags) 
 {
     if (ps->pkgs) 
         n_array_map_arg(ps->pkgs, (tn_fn_map2) mapfn_mark, &flags);
     
 }
+#endif
+
+struct flags_s {
+    unsigned flags_on;
+    unsigned flags_off;
+};
+
+
+static void mapfn_mark2(struct pkg *pkg, struct flags_s *fs) 
+{
+    n_assert(fs);
+
+    if (fs->flags_on)
+        pkg->flags |= fs->flags_on;
+
+    if (fs->flags_off)
+        pkg->flags &= ~fs->flags_off;
+    
+}
+
+void packages_mark(tn_array *pkgs, unsigned flags_on, unsigned flags_off) 
+{
+    struct flags_s fs;
+
+    fs.flags_on = flags_on;
+    fs.flags_off = flags_off;
+    
+    n_array_map_arg(pkgs, (tn_fn_map2) mapfn_mark2, &fs);
+}
+
 
 
 inline static int mark_package(struct pkg *pkg, int nodeps)
@@ -900,7 +929,8 @@
 {
     int i, nerr = 0, nodeps = 0, npatterns = 0;
 
-    pkgset_mark(ps, PS_MARK_OFF_ALL);
+    packages_mark(ps->pkgs, 0, PKG_INDIRMARK | PKG_DIRMARK);
+    //pkgset_mark(ps, PS_MARK_OFF_ALL);
 
     if (ps->flags & PSMODE_INSTALL_DIST)
         nodeps = inst->flags & INSTS_NODEPS;
@@ -999,7 +1029,8 @@
         
         else {
             if ((inst->flags & INSTS_FORCE) == 0)
-                pkgset_mark(ps, PS_MARK_OFF_ALL);
+                packages_mark(ps->pkgs, 0, PKG_INDIRMARK | PKG_DIRMARK);
+            //pkgset_mark(ps, PS_MARK_OFF_ALL);
             logn(LOGERR, _("Buggy package set."));
         }
     }
--- pkgset.h	24 Oct 2002 16:23:10 -0000	1.36
+++ pkgset.h	14 Nov 2002 13:35:19 -0000
@@ -143,12 +143,14 @@
 /* uninstall.c */
 int uninstall_usrset(struct usrpkgset *ups, struct inst_s *inst,
                      struct install_info *iinf);
-
+#if 0
 #define PS_MARK_OFF_ALL      (1 << 0)
 #define PS_MARK_OFF_DEPS     (1 << 1)
 #define PS_MARK_ON_INTERNAL  (1 << 2) /* use with one of above PS_MARK_* */
 
 void pkgset_mark(struct pkgset *ps, unsigned markflags);
+#endif
+
 
 int pkgset_fetch_pkgs(const char *destdir, tn_array *pkgs, int nosubdirs);
 
@@ -166,7 +168,21 @@
 
 int pkgset_rpmprovides(const struct pkgset *ps, const struct capreq *req);
 
+
+struct pkgscore_s {
+    char        pkgbuf[512];
+    int         pkgname_off;
+    struct pkg  *pkg;
+};
+
+void pkgscore_match_init(struct pkgscore_s *psc, struct pkg *pkg);
+int pkgscore_match(struct pkgscore_s *psc, const char *mask);
 void packages_score(tn_array *pkgs, tn_array *patterns, unsigned scoreflag);
+
+void packages_mark(tn_array *pkgs, unsigned flags_on, unsigned flags_off);
+
+#define packages_unmark_all(pkgs) packages_mark(pkgs, 0, PKG_INDIRMARK | PKG_DIRMARK)
+
 int packages_fetch(tn_array *pkgs, const char *destdir, int nosubdirs);
 int packages_rpminstall(tn_array *pkgs, struct pkgset *ps, struct inst_s *inst);
 
--- shell/install.c	18 Oct 2002 10:34:41 -0000	1.22
+++ shell/install.c	14 Nov 2002 13:35:19 -0000
@@ -209,7 +209,7 @@
         goto l_end;
     }
 
-    pkgset_mark(cmdarg->sh_s->pkgset, PS_MARK_OFF_ALL);
+    packages_unmark_all(cmdarg->sh_s->pkgset->pkgs);
     
     for (i=0; i < n_array_size(shpkgs); i++) {
         struct shpkg *shpkg = n_array_nth(shpkgs, i);
--- vfile/vftp/ftp.c	7 Nov 2002 16:43:30 -0000	1.19
+++ vfile/vftp/ftp.c	14 Nov 2002 13:35:20 -0000
@@ -86,6 +86,7 @@
 {
     if (*errmsg == '\0')
         return NULL;
+    
     return errmsg;
 }
 
@@ -100,6 +101,14 @@
     vftp_errno = err_no;
 }
 
+static int vftp_sigint_reached(void)
+{
+    int v;
+    if ((v = sigint_reached()) && vftp_errno == 0)
+        vftp_set_err(EINTR, _("connection cancelled"));
+    
+    return v;
+}
 
 
 static int do_ftp_cmd(int sock, char *fmt, va_list args)
@@ -107,7 +116,7 @@
     char     buf[1024], tmp_fmt[256];
     int      n;
 
-    if (sigint_reached())
+    if (vftp_sigint_reached())
         return 0;
 
     snprintf(tmp_fmt, sizeof(tmp_fmt), "%s\r\n", fmt);
@@ -289,7 +298,7 @@
         FD_SET(sockfd, &fdset);
         errno = 0;
         if ((rc = select(sockfd + 1, &fdset, NULL, NULL, &to)) < 0) {
-            if (sigint_reached()) {
+            if (vftp_sigint_reached()) {
                 is_err = 1;
                 errno = EINTR;
                 break;
@@ -367,10 +376,8 @@
                 break;
                 
             case EINTR:
-                if (sigint_reached()) {
-                    vftp_set_err(vftp_errno, _("connection canceled"));
+                if (vftp_sigint_reached()) 
                     break;
-                }
                 
             default:
                 vftp_set_err(vftp_errno, "%s: %m", _("unexpected EOF"));
@@ -389,7 +396,7 @@
     int is_err = 0;
 
 
-    if (sigint_reached())
+    if (vftp_sigint_reached())
         return 0;
     
     ftp_response_init(&resp);
@@ -407,7 +414,7 @@
             if (response_complete(&resp))
                 break;
 
-            if (sigint_reached()) {
+            if (vftp_sigint_reached()) {
                 is_err = 1;
                 break;
             }
@@ -518,7 +525,7 @@
     vftp_errno = 0;
     
     do {
-        sigint_reached();
+        sigint_reset();
         
         sockfd = socket(resp->ai_family, resp->ai_socktype, resp->ai_protocol);
         if (sockfd < 0)
@@ -531,6 +538,10 @@
         if (alarm_reached)
             vftp_errno = errno = ETIMEDOUT;
         
+        else if (vftp_sigint_reached()) {
+            errno = EINTR;
+            break;
+        }
         uninstall_alarm();
         close(sockfd);
         sockfd = -1;
@@ -546,6 +557,7 @@
         *addr->ai_addr = *resp->ai_addr;
     }
 
+    uninstall_alarm();
     freeaddrinfo(res);
     return sockfd;
 }
@@ -561,7 +573,7 @@
     if ((sockfd = to_connect(host, portstr, addr)) < 0)
         return 0;
     
-    if (sigint_reached())
+    if (vftp_sigint_reached())
         return 0;
     
     errno = 0;
@@ -859,7 +871,7 @@
 	tv.tv_usec = 0;
         
         rc = select(in_fd + 1, &fdset, NULL, NULL, &tv);
-        if (sigint_reached()) {
+        if (vftp_sigint_reached()) {
             is_err = 1;
             errno = EINTR;
             break;
@@ -939,13 +951,13 @@
     if ((total_size = ftpcn_size(cn, path)) < 0)
         goto l_err;
 
-    if (sigint_reached())
+    if (vftp_sigint_reached())
         goto l_err;
     
     if ((sockfd = ftpcn_pasv(cn)) <= 0)
         goto l_err;
 
-    if (sigint_reached())
+    if (vftp_sigint_reached())
         goto l_err;
 
     if (out_fdoff < 0)
--- vfile/vhttp/http.c	7 Nov 2002 16:43:31 -0000	1.12
+++ vfile/vhttp/http.c	14 Nov 2002 13:35:20 -0000
@@ -149,6 +149,16 @@
     vhttp_errno = err_no;
 }
 
+static int vhttp_sigint_reached(void)
+{
+    int v;
+    if ((v = sigint_reached()) && vhttp_errno == 0)
+        vhttp_set_err(EINTR, _("connection cancelled"));
+
+    return v;
+}
+
+
 static char *make_req_line(char *buf, int size, char *fmt, ...) 
 {
     va_list  args;
@@ -451,7 +461,7 @@
         FD_SET(sockfd, &fdset);
         errno = 0;
         if ((rc = select(sockfd + 1, &fdset, NULL, NULL, &to)) < 0) {
-            if (sigint_reached()) {
+            if (vhttp_sigint_reached()) {
                 is_err = 1;
                 errno = EINTR;
                 break;
@@ -530,11 +540,9 @@
                 break;
                 
             case EINTR:
-                if (sigint_reached()) {
-                    vhttp_set_err(vhttp_errno, _("connection canceled"));
+                if (vhttp_sigint_reached()) 
                     break;
-                }
-                
+
             default:
                 vhttp_set_err(vhttp_errno, "%s: %m", _("unexpected EOF"));
                 
@@ -642,7 +650,7 @@
     while (1) {
         int n;
 
-        if (sigint_reached()) {
+        if (vhttp_sigint_reached()) {
             is_err = 1;
             break;
         }
@@ -790,9 +798,9 @@
         if (alarm_reached)
             vhttp_errno = errno = ETIMEDOUT;
 
-        else if (sigint_reached() && errno == EINTR)
-            vhttp_errno = EINTR;
-        
+        else if (vhttp_sigint_reached() && errno == EINTR)
+            break;
+
         uninstall_alarm();
         close(sockfd);
         sockfd = -1;
@@ -801,7 +809,8 @@
 
     if (sockfd == -1)
         vhttp_set_err(errno, _("unable to connect to %s:%s: %m"), host, service);
-    
+
+    uninstall_alarm();
     freeaddrinfo(res);
     return sockfd;
 }
@@ -957,7 +966,7 @@
 	tv.tv_usec = 0;
         
         rc = select(in_fd + 1, &fdset, NULL, NULL, &tv);
-        if (sigint_reached()) {
+        if (vhttp_sigint_reached()) {
             is_err = 1;
             errno = EINTR;
             break;
